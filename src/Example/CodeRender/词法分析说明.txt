
/*
语义解析表达式知识库规范
+  连接两个规则表达式名称，表示两个规则名指定的表达式按照先后顺序必须都匹配成功（形成多个代码对象）
|	 连接两个规则表达式名称，表示两个规则名指定的表达式只要有一个匹配成功则该表达式成功(只针对当前的一个代码对象)
=  包表达式声明定义
N<规则表达式名,循环控制达式名> 表示指定的规则表达式要做N次匹配,直到当前包结束或者没有匹配到循环控制达式时 ，循环控制达式不影响匹配结果
包<包起始规则表达式,包终止规则表达式,规则表达式名> 指定一个包的解析匹配规则
xxx<yyy>	表示一个语法匹配规则表达式名和表达式类型名 如 函数声明1<函数声明>=返回类型1+调用约定|NULL
NULL<规则表达式名> 表示表达式匹配失败也可返回成功（将填充默认值）
NULL_TRUE 特殊表达式，直接返回表达式匹配成功 用于解析预留接口
NULL_FALSE 特殊表达式，直接返回表达式匹配失败 用于解析预留接口
xxx(yyy)	表示一个词法匹配规则表达式名和表达式类型名 如 句尾1(句尾)=; 词内置类型匹配名有 词型，符号型，整型，浮点型，字符串型,字符型 暂时合并到表达式
ROOT<表达式名> 表示语义解析根入口
G(xxx)	表示一个表达式 G(表达式名1|表达式名2)	暂时不支持
WORD(xxx)	表匹配一个词 比如WORD(;)


比如定义C++ 类声明的解析规则
ROOT<类声明>
类声明<类声明>=类声明1<类声明>|类声明2<类声明>|类声明3<类声明>
类声明1<类声明>=NULL<类模板声明>+类头关键词+类名+NULL<继承类表>+包<类声明包开始,类声明包结束,类声明体>
类声明2<类声明>=NULL_FALSE
类声明3<类声明>=NULL_FALSE

类模板声明<类模板声明>=类模板声明1|类模板声明2
类模板声明1<类模板声明>=模板关键词+包<模板声明参数包开始,模板声明参数包结束,模板声明参数表>
类模板声明2<类模板声明>=NULL
模板声明参数包开始<模板声明参数包开始>=<
模板声明参数包结束<模板声明参数包结束>=>
模板声明参数表<模板声明参数表>=N<模板声明参数声明>+模板声明参数声明尾
模板声明参数声明<模板声明参数声明>=WORD(typename)+词型+WORD(,)
模板声明参数声明尾<模板声明参数声明尾>=WORD(typename)+词型+WORD(>)

类头关键字<类头关键字>=word(class)
类名<类名>=词型

继承类表=WORD(:)+N<继承类表参数>+继承类表参数结束
继承类表参数<继承类表参数>=word(public)+词型+word(,)
继承类表参数结束<继承类表参数结束>=word(public)+词型

类声明包开始<类声明包开始>=word({)
类声明包结束<类声明包结束>=word(})+word(;)

类声明体<类声明体>=N<类声明体内容>
类声明体内容1<类声明体内容>=word(public)+word(:)
类声明体内容2<类声明体内容>=word(protected)+word(:)
类声明体内容3<类声明体内容>=word(private)+word(:)
类声明体内容4<类声明体内容>=类声明体内容1|类声明体内容2|类声明体内容3

类声明体内容5<类声明体内容>=函数声明|函数定义
类声明体内容6<类声明体内容>=变量声明|变量声明表
类声明体内容7<类声明体内容>=NULL_FALSE
类声明体内容8<类声明体内容>=NULL_FALSE

类声明体内容<类声明体内容>=类声明体内容1|类声明体内容2|类声明体内容3|类声明体内容4|类声明体内容5|类声明体内容6|类声明体内容7|类声明体内容8

函数定义<函数定义>=NULL_FALSE
函数声明<函数声明>=函数返回型别+NULL<函数调用约定>+函数名+包<函数声明包开始,函数声明包结束,函数声明参数表>
函数返回型别<函数返回型别>=词型
函数调用约定<函数调用约定>=word(_stdcall)|word(__stdcall)
函数名<函数名>=词型
函数声明包开始<函数声明包开始>=WORD(()
函数声明包结束<函数声明包结束>=WORD())+WORD(;)
函数声明参数表<函数声明参数表>=N<函数声明参数声明>+函数声明参数声明尾
函数声明参数声明<函数声明参数声明>=词型+词型+word(,)
函数声明参数声明尾<函数声明参数声明尾>=词型+词型+word(\))

变量声明<变量声明>=词型+词型+word(;)
变量声明表<变量声明表>=N<变量声明表单元变量声明>+变量声明表单元变量声明尾
变量声明表单元变量声明<变量声明表单元变量声明>=词型+词型+word(,)
变量声明表单元变量声明尾<变量声明表单元变量声明尾>=词型+词型+word(;)
*/

/*
模式处理合成表达式定义
表达式为真，则代码返回给上层表达式
MAKE_N<代码节点,第一个代码节点MAKE,中间的过程代码节点MAKE,末尾的代码节点MAKE> 穷举所有符合代码节点表达式的代码节点，然后交由后面的MAKE表达式处理
MAKE_ONE<代码节点,代码节点MAKE> 只MAKE处理第一个符合代码节点表达式的代码节点 
MAKE_ADD<MAKE表达式字符串的表达式名称>	添加或者设置一条表达式
WORD(x) 返回字符串，如果字符串中有"则需要在前面加\
NOT<MAKE表达式> 如果MAKE表达式成功则返回假，用于条件控制执行，并将MAKE表达式的结果抛弃不加入结果链
IF<MAKE表达式> 如果MAKE表达式成功则返回真，用于条件控制执行，并将MAKE表达式的结果抛弃不加入结果链
DEBUGOUT<"字符串">	打印字符串
DEBUGOUT<MAKE表达式> 打印MAKE表达式生成的结果，并影响参与计算的表达式真假状态
MAKE_TO<MAKE表达式,保存目标对象名> 如果MAKE表达式为真则将其结果保存到目标对象名指定的对象中去
MAKE_MAKECODE<需要解析处理的源对象,处理源对象的脚本对象>  对象可以是一个MAKE表达式返回的字符串，也可以直接是一个对象字符串如文件路径
MAKE_CODE_TO<源对象,处理源对象的MAKE表达式,输出对象> 对象可以是文件路径字符串或者是一个MAKE表达式结果,处理源对象的MAKE表达式 对 源对象分析处理后的结果存入 输出对象
MAKE_BIND_ROUTING<被绑定的虚路径名字符串,需要映射到虚路径的真实路径字符串>
+  表达式结果连接并流程控制 A+B 如果A为真则执行B，AB都为真则返回真
&  表达式结果连接并流程控制 A&B 不管A执行是否成功，都需执行B, AB只要有一个为真则返回真
#  表达式结果连接并流程控制 A#B 与+意义相同只是返回的结果不是用句连接，而是词的融合
|  表达式结果连接并流程控制 A|B	如果A为真，则不执行B，跳过B执行下一个表达式，如果A为假，则执行B,返回结果为A或B,返回的代码是真值的那个表达式MAKE结果
*/
