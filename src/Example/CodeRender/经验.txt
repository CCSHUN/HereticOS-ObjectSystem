问题不能在局部系统解决，需要考虑系统中各个部件的细节元素时，需要将问题变换到问题域集中到点去解决问题。

傅里叶变换的思想就是将离散的各个点的数据变换到单值的一点集中解决问题。

列表语言可将问题严格约束在列表和表达式内

节点路由很容易出问题。是否检查脚本强制约束

有序的代码和无序的代码，最适合客观现实的代码可能是四不像的代码，尽管我们用各种办法刻意的用有形的代码是实现有形的系统，但是最符合客观现实的代码还是四不像的代码，我们需要重构系统使四不像的系统变成有形可控的系统，用C++写的代码因为系统的不适应可能更多的是四不像的代码才能正常工作完成业务。因为领域内的业务规则在实现成最终的C++系统代码时就是四不像的代码才合适，比如分布式对象模型，C++不得不在对象赋值中处理异常，正常的做法是每次通讯都要对这个异常做出正确的处理，这使领域内的业务设计变的很困难。

区分语法糖和语言本身无法达到的功能和境界，一个语言是不是需要我们必须学习，主要看他在其他领域是不是有我们已有语言无法完成的设计，比如元编程完成的某项设计工作将是我们语言无法设计的。语法糖可能会导致语言只能解释执行或者虚拟机执行，这在一些重要的系统设计领域几乎是不可能使用的。底层系统设计首选C(汇编)，这种语言在设计期是一种优秀语言。

语法糖造成的困惑，语法扑朔迷离，易混淆，英文并不是通用语言，C和数学表达式才是。

C++ MPL lameda 实现的 DSL 本身还是将上层领域语言隐射到C++代码，其实属于同一阶段内语言（不利于构建多层平台架构），这种DSL设计起来很难有更高阶领域内抽象，设计复杂，不适合做灵活的系统设计。


同阶（同领域）问题自指解决，不同阶问题（不同领域）问题自指解决（泛型 所有水果的颜色）


C++本身支持泛型，即同一问题的特定领域集中解决问题，但是在底层无这样的能力，所以构建系统平台几乎很难用面向对象化泛型思想自指的解决自身体层平台问题。也就是说C++代码已经受限在特定系统平台之上，我们不能用它写Web应用就是这个原因

代码即对象。如果对象的成员函数能够被赋值改变成另外一个函数